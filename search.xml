<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F08%2F28%2Farithmetic%2F</url>
    <content type="text"><![CDATA[排序算法排序算法是将同一类无序或有序的数据排列成自己特定顺序的一系列算法，一般情况是排列成升序或是降序。本篇博客将介绍八种排序算法 该篇博客基本是向其他博主借鉴学习，借用其他博主的图片为学习所用，在博客底部会注明图片来源 一.插入排序算法原理 插入算法是一种简单的排序算法,把无序的先排序成有序的，再将其他单个元素一个一个插入到有序序列中，找到相应的位置，然后放置到相应位置。#### 算法步骤 1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。#### 代码实现(java)1234567891011121314static void inSpace(int[] a)&#123;//插入排序，就是把这个之前的当做已经排好的，然后插入到前面去 int j,temp; if (a.length &lt;= 2)return; for(int i = 0;i&lt;a.length-1;i++)&#123; j=i+1; temp = a[j]; while(j&gt;=1 &amp;&amp; temp&lt;a[j-1])&#123;//先判断长度在比大小防止越界 a[j]=a[j-1];//往右让出一个位置 j--;//j指向这个位置如果条件不符合就是这里 &#125; a[j]=temp;//temp和j指向的位置调换 &#125; //for(int i:a)System.out.println(i); &#125;#### 算法示意图### 二.希尔排序 算法原理 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率 但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。#### 算法步骤1. 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；2. 按增量序列个数k，对序列进行k 趟排序；3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。#### 代码实现(c++)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define MAXNUM 10void main()&#123; void shellSort(int array[],int n,int t);//t为排序趟数 int array[MAXNUM],i; for(i = 0;i &lt; MAXNUM;i++) scanf("%d",&amp;array[i]); shellSort(array,MAXNUM,int(log(MAXNUM + 1) / log(2)));//排序趟数应为log2(n+1)的整数部分 for(i = 0;i &lt; MAXNUM;i++) printf("%d ",array[i]); printf("\n");&#125;//根据当前增量进行插入排序void shellInsert(int array[],int n,int dk)&#123; int i,j,temp; for(i = dk;i &lt; n;i++)//分别向每组的有序区域插入 &#123; temp = array[i]; for(j = i-dk;(j &gt;= i % dk) &amp;&amp; array[j] &gt; temp;j -= dk)//比较与记录后移同时进行 array[j + dk] = array[j]; if(j != i - dk) array[j + dk] = temp;//插入 &#125;&#125;//计算Hibbard增量int dkHibbard(int t,int k)&#123; return int(pow(2,t - k + 1) - 1);&#125;//希尔排序void shellSort(int array[],int n,int t)&#123; void shellInsert(int array[],int n,int dk); int i; for(i = 1;i &lt;= t;i++) shellInsert(array,n,dkHibbard(t,i));&#125;//此写法便于理解，实际应用时应将上述三个函数写成一个函数。#### 算法示意图### 三.选择排序 算法原理选择排序其实是日常的常见的排序，在无序的序列中找出第一小的，然后找出第二小的，以此类推，到最后就按顺序排好了 算法步骤 选取第一个位置作为参照 循环找剩下序列(包括参照位置)中最小的 与参照位置互换 进行下一个位置的排序 代码实现(java)12345678910static void selectSort(int[] a)&#123;//选择排序，把第i个数值换成是i(包括i)之后的序列中最小的 for (int i = 0; i &lt; a.length-1; i++) &#123; int min=i;//包括i,假设i是最小的 for (int j = i+1; j &lt; a.length ; j++) &#123; if (a[j]&lt;a[min])min=j;//冒泡 &#125; swap(a,i,min); &#125; //for(int i:a)System.out.println(i);&#125; 算法示意图 四.冒泡排序算法原理冒泡排序和选择排序其实很像，只不过实现方式不一样，冒泡排序是从起始位置开始，往后纠正相邻位置的顺序并交换。在第一个参照的遍历后，就能找出最大的并放在最末尾，第二次之后第二大的到了倒数第二的位置，以此类推就排序完了。 算法步骤以第一个为参照，往后交换并比较，做整个序列的遍历就行了 代码实现(java)12345678static void popSort(int[] a)&#123;//冒泡排序 for (int i = 0; i &lt; a.length-2; i++) &#123; for (int j = a.length-1; j &gt; i; j--) &#123; if (a[j]&lt;a[j-1])swap(a,j,j-1);//冒泡 &#125; &#125; //for(int i:a)System.out.println(i);&#125; 算法示意图 五.归并排序算法原理归并排序是先分割再整合的算法，重点在于整合部分，归并排序先把整个序列分割成最小的有序序列，一般情况下最后的分割方式下都是分割成单个数值，然后合并成有序数列。合并时，进行合并的时候两个数列]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my blog]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>centOS</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
</search>
