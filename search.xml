<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[jvmone]]></title>
    <url>%2F2018%2F09%2F04%2Fjvmone%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F08%2F28%2Farithmetic%2F</url>
    <content type="text"><![CDATA[排序算法排序算法是将同一类无序或有序的数据排列成自己特定顺序的一系列算法，一般情况是排列成升序或是降序。本篇博客将介绍八种排序算法 该篇博客基本是向其他博主借鉴学习，借用其他博主的图片为学习所用，在博客底部会注明图片来源 一.插入排序算法原理插入算法是一种简单的排序算法,把无序的先排序成有序的，再将其他单个元素一个一个插入到有序序列中，找到相应的位置，然后放置到相应位置。 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。 代码实现(java)1234567891011121314static void inSpace(int[] a)&#123;//插入排序，就是把这个之前的当做已经排好的，然后插入到前面去 int j,temp; if (a.length &lt;= 2)return; for(int i = 0;i&lt;a.length-1;i++)&#123; j=i+1; temp = a[j]; while(j&gt;=1 &amp;&amp; temp&lt;a[j-1])&#123;//先判断长度在比大小防止越界 a[j]=a[j-1];//往右让出一个位置 j--;//j指向这个位置如果条件不符合就是这里 &#125; a[j]=temp;//temp和j指向的位置调换 &#125; //for(int i:a)System.out.println(i); &#125; 算法示意图 二.希尔排序算法原理 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率 但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 算法步骤 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 代码实现(c++)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define MAXNUM 10void main()&#123; void shellSort(int array[],int n,int t);//t为排序趟数 int array[MAXNUM],i; for(i = 0;i &lt; MAXNUM;i++) scanf("%d",&amp;array[i]); shellSort(array,MAXNUM,int(log(MAXNUM + 1) / log(2)));//排序趟数应为log2(n+1)的整数部分 for(i = 0;i &lt; MAXNUM;i++) printf("%d ",array[i]); printf("\n");&#125;//根据当前增量进行插入排序void shellInsert(int array[],int n,int dk)&#123; int i,j,temp; for(i = dk;i &lt; n;i++)//分别向每组的有序区域插入 &#123; temp = array[i]; for(j = i-dk;(j &gt;= i % dk) &amp;&amp; array[j] &gt; temp;j -= dk)//比较与记录后移同时进行 array[j + dk] = array[j]; if(j != i - dk) array[j + dk] = temp;//插入 &#125;&#125;//计算Hibbard增量int dkHibbard(int t,int k)&#123; return int(pow(2,t - k + 1) - 1);&#125;//希尔排序void shellSort(int array[],int n,int t)&#123; void shellInsert(int array[],int n,int dk); int i; for(i = 1;i &lt;= t;i++) shellInsert(array,n,dkHibbard(t,i));&#125;//此写法便于理解，实际应用时应将上述三个函数写成一个函数。 算法示意图 三.选择排序算法原理选择排序其实是日常的常见的排序，在无序的序列中找出第一小的，然后找出第二小的，以此类推，到最后就按顺序排好了 算法步骤 选取第一个位置作为参照 循环找剩下序列(包括参照位置)中最小的 与参照位置互换 进行下一个位置的排序 代码实现(java)12345678910static void selectSort(int[] a)&#123;//选择排序，把第i个数值换成是i(包括i)之后的序列中最小的 for (int i = 0; i &lt; a.length-1; i++) &#123; int min=i;//包括i,假设i是最小的 for (int j = i+1; j &lt; a.length ; j++) &#123; if (a[j]&lt;a[min])min=j;//冒泡 &#125; swap(a,i,min); &#125; //for(int i:a)System.out.println(i);&#125; 算法示意图 四.冒泡排序算法原理冒泡排序和选择排序其实很像，只不过实现方式不一样，冒泡排序是从起始位置开始，往后纠正相邻位置的顺序并交换。在第一个参照的遍历后，就能找出最大的并放在最末尾，第二次之后第二大的到了倒数第二的位置，以此类推就排序完了。 算法步骤以第一个为参照，往后交换并比较，做整个序列的遍历就行了 代码实现(java)12345678static void popSort(int[] a)&#123;//冒泡排序 for (int i = 0; i &lt; a.length-2; i++) &#123; for (int j = a.length-1; j &gt; i; j--) &#123; if (a[j]&lt;a[j-1])swap(a,j,j-1);//冒泡 &#125; &#125; //for(int i:a)System.out.println(i);&#125; 算法示意图 五.归并排序算法原理归并排序是先分割再整合的算法，重点在于整合部分，归并排序先把整个序列分割成最小的有序序列，一般情况下最后的分割方式下都是分割成单个数值，然后合并成有序数列。合并时，进行合并的时候两个数列必定为有序的，因为它是从之前的小的序列进行有序的合并之后得到的，往前推就是单个数字，所以我们保证了进行一次合并的时候两个序列一定有序。然后创建一个序列，取两个序列的起始位置作为比较参照位的数值，更小的那个参照位置则赋值给新的序列，被取走数值的那个序列参照位往后移动一位。直到一个序列的最后一位被取完，则停止比较，把还剩余数值的序列赋值给新序列（一位一位往后移动，因为是有序的）。这个过程很重要，先确定它一定有序后，直接按着两个序列下标来往后移动，往新序列插入的过程就是排序的过程，分解后归并就完成了排序 算法步骤 递归分解序列成一个一个的小序列 把小序列一个一个的合并成大序列 合并的时候按照下标顺序进行比较，然后插入新序列 代码实现(java)12345678910111213141516171819202122232425262728//归并排序 start static void mergeSortAdd(int[] a,int left ,int mid,int right )&#123; int i = left,n = mid; int j = mid+1,m = right; int t=0; int[] b = new int[right-left+1]; while(i&lt;=n &amp;&amp; j&lt;=m)&#123; if (a[i]&lt;=a[j]) b[t++] = a[i++]; else b[t++] = a[j++]; &#125; while(i&lt;=n) b[t++] = a[i++]; while(j&lt;=m) b[t++] = a[j++]; for (int k = left,l = 0; k &lt;= right; k++,l++) a[k] = b[l]; &#125; static void mergeSort(int a[],int left,int right)&#123; if (left&lt;right)&#123;//基本都是拆分成单个数字，因为你无法确定两个数字的小数组是否有序 int mid = (left+right)/2; mergeSort(a,left,mid); mergeSort(a,mid+1,right); mergeSortAdd(a,left,mid,right); &#125; &#125; //归并排序 end 算法示意图 六.快速排序算法原理上面提到的归并算法中有个思想是分治，把一个大的个体分成一个个小的个体进行比较，快速排序也是利用了分治的思想。快速排序就像是做一个筛选，把大的放左边，小的放右边，加上分治的思想，分割到最小模块的时候，两个数值的序列，小的和大的分在两边就是有序的。快速排序先把比参照位小的放左边，大的放右边，这个操作保证了左边所有的都小于右边，所以当左右都排序好的时候，整个序列都是有序的。我们再把左边作为一整个序列进行快速排序，直至分割到最小的序列整个序列都是有序的。 算法步骤 取第一个作为参照位置，把整个序列分成大小两边 把其中一边再作为进行快速排序的序列，取其第一个数值作为参照位置分成大小两边 由此递归下去整个数组都是有序的 代码实现(java)123456789101112131415161718static void speedSort(int[] a,int left ,int right)&#123;//快速排序 if(left&lt;right)&#123; int temp = a[left]; int i = left; int j = right; while (i&lt;j)&#123; while (i&lt;j &amp;&amp; a[i]&lt;=temp) i++; while(i&lt;j &amp;&amp; a[j]&gt;=temp) j--; if(i&lt;j) swap(a,i,j); &#125; if(a[i]&gt;temp) i--; swap(a,i,left); speedSort(a,left,i-1); speedSort(a,i+1,right); &#125;&#125; 算法示意图 七.堆排序算法原理堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。先把整个序列整理成一个大顶堆，然后把堆顶的数值放到最末尾，在下次重排序的时候不包括进去，由此把第二大的放在了堆顶，把堆顶和倒数第二个进行置换，如此循环到最后就排序完了。每次的排序就是父节点和两个儿子的三选一(在叶子的时候可能只有一个儿子)把最大的放到顶部(类似分治)全部循环一边就把最大的挑选到顶部了，这个排序的过程需要有个前提就是这棵树是小顶堆，所以每次都能找到最大的。 算法步骤 把整个序列整理成一个完全二叉树 再整理成小顶堆 开始把最大的放到堆顶后置换到最后一位，再进行除已排序的序列的排序，遍历完整个数组之后即可完成排序 代码实现(java)1234567891011121314151617181920212223 //堆排序 start static void heapSort(int[] a,int i,int length)&#123; int left = i*2+1; int right = i*2+2; int largest; if(left &lt; length &amp;&amp; a[left]&gt;a[i])largest = left; else largest = i; if(right&lt; length &amp;&amp; a[right]&gt;a[largest])largest = right;//这里最容易出错，要和最大的比较而不是和父节点比较 if (largest!=i)&#123;//如果找到子节点有最大值，交换后把子节点的位置做新的堆下沉 swap(a,largest,i); heapSort(a,largest,length); &#125; &#125; static void heapSortStart(int[] a)&#123; for (int i = (a.length)/2; i &gt;= 0 ; i--) heapSort(a,i,a.length);//创建小顶堆，从中间向上整理 for (int i = a.length-1; i &gt;=0; i--) &#123; swap(a,0,i);//栈顶拿来存已经整理的数据 heapSort(a,0,i); &#125;// for(int i:a)System.out.print(" "+i); &#125; // 堆排序 end 算法示意图 八.计数排序算法原理这个其实特别简单的，本应该写在前面的，但是这个顺序我也是随便写的。计数排序就是计数，比如范围是1-10 序列是[2,8]，在计数器中第二位和第八位加个一，按照计数器的顺序进行遍历，计数器有多少数值就输出多少次。(我觉得使用的场景少，了解一下就ok了) 算法步骤 创建一个计数器数组，取决于数组中的最大数值(关键就在这里，万一排个[5,1,99999999]这计数器就太浪费了) 遍历序列，把数值作为计数器的下标，计数器数值加一 按照计数器的遍历顺序放回序列中 代码实现(js)12345678910111213141516171819202122function countingSort(arr, maxValue) &#123; var bucket = new Array(maxValue + 1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++; &#125; for (var j = 0; j &lt; bucketLen; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr;&#125; 算法示意图 九.桶排序算法原理桶排序就是把一个范围的数值放进桶里排序，其实有点像快速排序，快速排序是二分的分治的，而桶排序就是蠢蠢的分了一次。如果桶的数量是十，就意味着把这个序列的数值最大不能大于100(这里是我的理解),先把十位数相同的放进每个桶里，然后桶里进行排序之后再按照十位数放回序列里。 算法步骤 设置一个定量的数组当作空桶 遍历输入数据，并且把数据一个一个放到对应的桶里去 对每个不是空的桶进行排序 从不是空的桶里把排好序的数据拼接起来。 代码实现(js)12345678910111213141516171819202122232425262728293031323334353637383940function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; // 输入数据的最小值 &#125; else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; // 输入数据的最大值 &#125; &#125; // 桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; // 利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr;&#125; 算法示意图 十.基数排序算法原理基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法步骤 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 代码实现(js)123456789101112131415161718192021222324var counter = [];function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; return arr;&#125; 算法示意图 算法复杂度这只是部分的 关于此篇博客 希尔排序我感觉一般所以直接搬用了其他博主的代码与解析，其原理和实现我都自己做了。最后三个排序我感觉蠢蠢的但是肯定也有它们的应用场景，实现起来也特简单，所以我就直接搬用了其他博主的博客内容。整个博客其实就是自己学习所用，来试试自己学的怎样了，结果感觉还行。整个博客都是用自己的通俗的理解写出来的，主要是为了给自己复习，写的易懂一些，所以肯定很不严谨，欢迎各位的批评指正，我会及时修改。 引用博客 https://www.cnblogs.com/RainyBear/p/5258483.htmlhttps://www.cnblogs.com/onepixel/articles/7674659.html]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my blog]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>centOS</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
</search>
