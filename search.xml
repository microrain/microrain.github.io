<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学习java虚拟机(三): 垃圾回收机制]]></title>
    <url>%2F2018%2F09%2F05%2Fjvmthree%2F</url>
    <content type="text"><![CDATA[学习java虚拟机(三): 垃圾回收机制之前我在学习jvm内存分布的时候，提到了java堆也被称为GC堆，这是因为堆是存储已经实例化的对象和数组的地方，内存占用的比较多，所以需要去判断有些数据是否还有存在的价值，如果没价值，那么这些数据将会被清除，以达到整理内存空间来避免无限增长的内存空间导致的oom。作为一个合格的Java程序员，有必要了解Java GC相关知识。掌握GC知识一方面可以帮助我们快速排查因JVM导致的线上问题，另一方面也可以帮助我们在Java应用发布之前合理地对JVM进行调优，提高应用的执行效率、可靠性和健壮性。 该篇博客基本是向其他博主借鉴学习，借用其他博主的图片为学习所用，在博客底部会注明图片来源 接下来我们将从各个部分来了解垃圾回收机制 一.堆内存结构首先是对堆的划分，主要分为三个区域：新生代，老年代和永久代。新生代主要分为: eden ， from survivor 和to survivor 三个区域。 123456+---------------------------+-------------------------------+-------------------+| | | | | || Eden | S0 | S1 | Old generation | Perm || | | | | |+---------------------------+-------------------------------+-------------------+|&lt;----Young Gen Space------&gt;| 这些层次基本是从左往右，只要存活时间够长就会经过判断，一层一层往下走，到了永久层基本不会再进行回收了。永久代里面存放的是Class类元数据、方法描述等。 新生代分为eden s0 s1，s1 是和 s0 等大的一个内存区域，这是因为新生代主要使用的是复制算法，新生的对象进入s0 ，把需要的对象放入s1，然后清除s0的对象完成一次垃圾回收，然后把s1和s0进行交换位置，进行反复使用。 永久代这个概念，在HotSpot虚拟机中就是我们说的方法区，但是到了永久代基本都不需要垃圾回收了，所以在jdk1.7之后没有了永久代，取而代之的是元空间。 并非所有的对象创建都会在Eden区中分配内存空间。对于Serial和ParNew垃圾收集器,通过指定-XX:PretenureSizeThreshold={size}来设置超过这个阈值大小的对象直接进入老年代。 二.分代回收算法我们一般讨论的垃圾回收主要针对Java堆内存中的新生代和老年代，也正因为新生代和老年代结构上的不同，所以产生了分代回收算法，即新生代的垃圾回收和老年代的垃圾回收采用的是不同的回收算法。针对新生代，主要采用复制算法，而针对老年代，通常采用标记-清除算法或者标记-整理算法来进行回收。 1. 复制算法复制算法的思想是将内存分成大小相等的两块区域，每次使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块区域上，然后对该块进行内存回收。示例图如下所示： 这个算法实现简单，并且也相对高效，但是代价就是需要将牺牲一半的内存空间用于进行复制。有研究表明，新生代中的对象98%存活期很短，所以并不需要以1:1的比例来划分整个新生代，通常的做法是将新生代内存空间划分成一块较大的Eden区和两块较小的Survivor区，两块Survivor区域的大小保持一致。每次使用Eden和其中一块Survivor区，当回收的时候，将还存活的对象复制到另外一块Survivor空间上，最后清除Eden区和一开始使用的Survivor区。假如用于复制的Survivor区放不下存活的对象，那么会将对象存到老年代。 HotSpot虚拟机默认Eden和Survivor的大小比例是8:1:1，也就是说新生代中牺牲掉10%的空间而不是一半的空间。 2. 标记-清除算法标记清除算法分为标记和清除两个部分 在标记阶段将标记出需要回收的对象空间，然后在下一个阶段清除阶段里面，将这些标记出来的对象空间回收掉。这种算法有两个主要问题：一个是标记和清除的效率不高，另一个问题是在清理之后会产生大量不连续的内存碎片，这样会导致在分配大对象时候无法找到足够的连续内存而触发另一次垃圾收集动作。标记-清除算法示例图如下所示： 3. 标记-整理算法标记-整理(Mark-Compact)算法有效预防了标记-清除算法中可能产生过多内存碎片的问题。在标记需要回收的对象以后，它会将所有存活的对象空间挪到一起，然后再执行清理。示例图如下所示： 标记-整理通常会在标记-清除算法里面作为备选方案，为了防止标记-清除后产生大量内存碎片而无法为大对象分配足够内存的情况，如后面所讲的Serial Old收集器(基于标记-整理算法实现)将会作为CMS收集器(基于标记-清除算法实现)的备选方案。 三.垃圾回收器因为新生代和老年代的回收算法不一样，所以它们所使用的垃圾回收器也不一样。新生代主要有：serial ，parnew 和parallel scavenge收集器，老年代有 serial old ,Parallel Old 和CMS收集器。除此之外还有一个现在常用到的G1收集器，它适合新生代和老年代。 1. 新生代收集器 Serial收集器 Serial收集器作用于新生代，是一个单线程收集器，基于复制算法实现。在进行垃圾回收的时候仅使用单条线程并且在回收的过程中会挂起所有的用户线程(Stop The World)。Serial收集器是JVM client模式下默认的新生代收集器。 特别注意，Stop-The-World会挂起应用线程，造成应用的停顿。 ParNew收集器 ParNew收集器作用于新生代，是一个多线程收集器，基于复制算法实现。相对于Serial收集器而言，在垃圾回收的时候会同时使用多条线程进行回收，但是它跟Serial收集器一样，在回收过程中也是会挂起所有的用户线程，从而造成应用的停顿。 Parallel Scavenge收集器 Parallel Scavenge收集器同样作用于新生代，并且也是采用多线程和复制算法来进行垃圾回收。Parallel Scavenge收集器关注的是吞吐量，即使得应用能够充分使用CPU。它与ParNew收集器一样，在回收过程会挂起所有的用户线程，造成应用停顿。 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。即吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。如果虚拟机运行了100分钟，其中垃圾收集花了1分钟，那么吞吐量就是99%。 2. 老年代收集器 Serial Old收集器 Serial Old收集器作用于老年代，采用单线程和标记-整理算法来实现垃圾回收。在回收垃圾的时候同样会挂起所有用户线程，造成应用的停顿。一般来说，老年代的容量都比新生代要大，所以当发生老年代的垃圾回收时，STW经历的时间会比新生代所用的时间长得多。该收集器是JVM client模式下默认的老年代收集器。 Serial Old收集器还有一个重要的用途是作为CMS收集器的后备方案，在并发收集发生Concurrent Mode Failure的时候使用，进行内存碎片的整理。 Parallel Old收集器 Parallel Old收集器是Parallel Scavenge收集器的老年代版本，采用多线程和标记-整理算法来实现老年代的垃圾回收。这个收集器主要是为了配合Parallel Scavenge收集器的使用，即当新生代选择了Parallel Scavenge收集器的情况下，老年代可以选择Parallel Old收集器。 在JDK1.6以前并没有提供Parallel Scavenge收集器，所以在1.6版本以前，Parallel Scavenge收集器只能与Serial Old收集器搭配使用。 CMS收集器 CMS(Concurrent Mark Sweep)收集器是一款真正实现了并发收集的老年代收集器。CMS收集器以获取最短回收停顿时间为目标，采用多线程并发以及标记-清除算法来实现垃圾回收。CMS只在初始化标记和重新标记阶段需要挂起用户线程,造成一定的应用停顿(STW)，而其他阶段收集线程都可以与用户线程并发交替进行，不必挂起用户线程，所以并不会造成应用的停顿。CMS收集器可以最大程度地减少因垃圾回收而造成应用停顿的时间。 CMS垃圾收集分为以下几个阶段： (1) 初始化标记 (inital mark) 这个阶段仅仅是标记了GC Roots能够直接关联到的对象，速度很快，所以基本上感受不到STW带来的停顿。 (2) 并发标记 (concurrent mark) 并发标记阶段完成的任务是从第一阶段收集到的对象引用开始，遍历所有其他的对象引用，并标记所有需要回收的对象。这个阶段，收集线程与用户线程并发交替执行，不必挂起用户线程，所以并不会造成应用停顿。 (3) 并发预清除 (concurrent-pre-clean) 并发预清除阶段是为了下一个阶段做准备，为的是尽量减少应用停顿的时间。 (4) 重新标记 (remark) 这个阶段将会修正并发标记期间因为用户程序继续运作而导致标记产生变动的那部分对象的标记记录(有可能对象重新被引用或者新对象可以被回收)。这个阶段的停顿时间比初始标记阶段要长一些，但是远比并发标记的时间短。 (5) 并发清除 (concurrent sweep) 这个阶段将真正执行垃圾回收，将那些不被使用的对象内存回收掉。 (6) 并发重置 (concurrent reset) 收集器做一些收尾的工作，以便下一次GC周期能有一个干净的状态。 使用CMS要注意以下两个关键词： concurrent mode failure promotion failed 对于采用CMS进行老年代GC的程序而言，尤其要注意GC日志中是否有promotion failed和concurrent mode failure两种状况，当这两种状况出现时可能会触发Full GC。promotion failed是在进行Minor GC时，新生代的survivor区放不下,对象只能放入老年代，而此时老年代也放不下造成的。concurrent mode failure是在执行CMS GC的过程中同时有对象要放入老年代(满足一定年龄的对象或者大对象)，而此时老年代空间不足造成的。 通常我们把发生在新生代的垃圾回收称为Minor GC，而把发生在老年代的垃圾回收称为Major GC，而FullGC是指整个堆内存的垃圾回收，包括对新生代、老年代和持久代的回收。一般情况下应用程序发生Minor GC的次数要远远大于Major GC和Full GC的次数。 G1收集器 G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征. 被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点： 并行与并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。 空间整合：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。 可预测的停顿：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。 G1收集器的运作大致分为以下几个步骤： 初始标记 并发标记 最终标记 筛选回收 G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。 四.判断对象是否可回收一个对象是否可被回收或者说被标记回收，用了哪些方法去判断？我们接下来就是要探讨这个问题。我们先看一下内存的分配策略： 分配策略1. 对象优先在eden区分配目前主流的垃圾回收器都采用的分代方式去回收垃圾。在创建对象的时候，一般是在eden区分配对象内存，当eden内存不足的时候，它就会进行一次minor GC , 这时候回收器发现这些对象无法进入survivor区，通过分配担保机制把新生代的对象提前转移到老年代中去，如果未占满老年底就不会触发Full GC ,执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。 2. 大对象直接进入老年代大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。这样做是为了为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。 3. 长期存活的对象将进入老年代垃圾回收器使用了分代的思想，那么jvm就得分别出哪些得在新生代，哪些得在老年代。所以jvm会给每个对象分配一个年龄标识。 新生的对象存放在eden区，在第一次进行minorGC的时候，该对象生存下来，并且可以给survivor收容的话，就把该对象放入survivor区并把年龄设置为1.每当进行一次minorGC,并且该对象生存下来的话，年龄就加一，直到默认的年龄(默认年龄是15)后生存下来进入老年代.对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold来设置。 4. 动态对象年龄判定为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。 判断对象的死亡堆中存放着大量的对象和数组数据，垃圾回收器该怎么判断这个是死亡的对象或者是需要标记死亡的对象呢？我们大致可以这么分： 1. 引用计数法给一个对象进行引用标记，当有一个地方引用它就加一，当一个引用是失效就减一,当一个对象的引用为0的时候，就可以标记不可再用的对象。 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为0，于是引用计数算法无法通知 GC 回收器回收他们。 例如：123456789101112public class ReferenceCountingGc &#123; Object instance = null; public static void main(String[] args) &#123; ReferenceCountingGc objA = new ReferenceCountingGc(); ReferenceCountingGc objB = new ReferenceCountingGc(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; &#125;&#125; 2. 可达性分析算法这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。 在Java中，可作为GC Root的对象包括以下几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（即一般说的Native方法）引用的对象 3. 引用无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。 JDK1.2之前，Java中引用的定义很传统：如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。 JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱） 强引用 以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。 软引用（SoftReference） 如果一个对象只具有软引用，在引用计数器检测到的时候引用计数器不会加一。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。 软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。 弱引用（WeakReference） 如果一个对象只具有弱引用，在引用计数器检测到的时候引用计数器不会加一。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 虚引用（PhantomReference） “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。 虚引用主要用来跟踪对象被垃圾回收的活动。 虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。 特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。 4. 不可达的对象并非“非死不可”即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。 被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。 5. 如何判断一个常量是废弃常量运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？ 假如在常量池中存在字符串 “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。 6.如何判断一个类是无用的类方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？ 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。 关于此篇博客 这篇博客是从垃圾回收算法到垃圾回收器，最后解释了下判断一个对象在什么情况下会当成垃圾处理。垃圾回收算法总共有复制，标记-清除，标记-整理，然后对堆区域进行垃圾分代来做垃圾回收器，总共讲了七个垃圾回收器，主要是CMS和G1,主要的思想是并行和并发的合理利用来加快效率和吞吐量。最后是判断对象，常量和类的是否可回收性，主要是了解两个算法和引用的意义。里面的内容都很容易理解，这些博主的话语都很简洁直白，基本我都是CV，我写博客只要不涉及到代码，我基本都CV，在后面尽量慢慢改掉这个坏习惯吧。还有个参数配置和使用就不写了，想看的看下面的博客里面有。感谢大神的博客。 引用博客 搞定JVM垃圾回收就是这么简单.mdJava GC 介绍]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习java虚拟机(二): 常量池]]></title>
    <url>%2F2018%2F09%2F05%2Fjvmtwo%2F</url>
    <content type="text"><![CDATA[学习java虚拟机(二): 常量池上节讲到jvm基础的内存分布中，有个部分叫常量池，这里是一个特别的部分，而且有些时候会问到，所以单独做一个模块来讲 该篇博客基本是向其他博主借鉴学习，借用其他博主的图片为学习所用，在博客底部会注明图片来源 一.基本概念虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和floating point常量）和对其他类型，字段和方法的符号引用。对于String常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的，对于String类型，有一张固定长度的CONSTANT_String_info表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。 二.基本类型Java 基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。 123456789Integer a = 33;Integer b = 33;System.out.println(a == b)//输出trueInteger c = 333;Integer d = 333;System.out.println(c == d)//输出falseDouble e = 1.2;Double f = 1.2;System.out.println(e == f)//输出false 我们可以看Integer的缓存源代码12345public static Integer valueOf(int i)&#123; if(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i+(-IntegerCache.low)]; return new Ingeter(i);&#125; 应用场景 Integer i1=40；Java在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。 Integer i1 = new Integer(40);这种情况下会创建新的对象，所以尽量避免使用这种方式。123Ingeter i1 = 40;Ingeter i2 = new Ingeter(40);System.out.println(i1 == i2);//返回false 全部例子12345678910111213Integer i1 = 40;Integer i2 = 40;Integer i3 = 0;Integer i4 = new Integer(40);Integer i5 = new Integer(40);Integer i6 = new Integer(0);System.out.println("i1=i2 " + (i1 == i2));//trueSystem.out.println("i1=i2+i3 " + (i1 == i2 + i3));//trueSystem.out.println("i1=i4 " + (i1 == i4));//falseSystem.out.println("i4=i5 " + (i4 == i5));//falseSystem.out.println("i4=i5+i6 " + (i4 == i5 + i6));//true System.out.println("40=i5+i6 " + (40 == i5 + i6));//true 部分解释:语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。 三.String 类1.String的两种创建方式：123String str1 = "abcd";String str2 = new String("abcd");System.out.println(str1==str2);//false 这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。 只要使用new方法，便需要创建新的对象。 String类型的常量池比较特殊。它的主要使用方法有两种： 直接使用双引号声明出来的String对象会直接存储在常量池中。 如果不是用双引号声明的String对象，可以使用String提供的intern方String.intern() 是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。 123456String s1 = new String("计算机");String s2 = s1.intern();String s3 = "计算机";System.out.println(s2);//计算机System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，System.out.println(s3 == s2);//true，因为两个都是常量池中的String对 String字符串拼接 尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的花，可以使用 StringBuilder 或者 StringBuffer。 123456String str3 = "str" + "ing";//常量池中的对象String str4 = str1 + str2; //在堆上创建的新的对象 String str5 = "string";//常量池中的对象System.out.println(str3 == str4);//falseSystem.out.println(str3 == str5);//trueSystem.out.println(str4 == str5);//false String s1 = new String(“abc”);这句话创建了几个对象？创建了两个对象。1234String s1 = new String("abc");// 堆内存的地值值String s2 = "abc";System.out.println(s1 == s2);// 输出false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。System.out.println(s1.equals(s2));// 输出true 解释：先有字符串”abc”放入常量池，然后 new 了一份字符串”abc”放入Java堆(字符串常量”abc”在编译期就已经确定放入常量池，而 Java 堆上的”abc”是在运行期初始化阶段才确定)，然后 Java 栈的 str1 指向Java堆上的”abc”。 关于此篇博客 这篇博客大部分是复制别的博客的内容，这篇博客主要目的是复制记忆这部分知识，因为这部分知识不难，代码都是自己测试了并且手打的，把这篇博客放在这里是为了下次复习可用。 引用博客 Java面试通关手册 –Snailclimb]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习java虚拟机(一): 基础原理]]></title>
    <url>%2F2018%2F09%2F04%2Fjvmone%2F</url>
    <content type="text"><![CDATA[学习java虚拟机(一): 基础原理java虚拟机简称jvm，该部分知识是学习java比较重要的一部分，如果要深入java进行研究学习，那jvm就是入门的标准。 该篇博客基本是向其他博主借鉴学习，借用其他博主的图片为学习所用，在博客底部会注明图片来源 一.运行流程java一直以来的口号都是一次编译处处运行,在编译java文件成class文件之后，就可以在任何拥有java虚拟机的机器上运行。该虚拟机会将该class文件进行编译，转换成机器码让机器识别,最终就可以被运行。当jvm得到class文件之后又进行了哪些步骤？首先，jvm会去寻找在系统中的jvm.cfg文件，然后从文件中读取你所选择的虚拟机。 在学习这个之前，我们需要了解一件事情，就是JDK和JRE的区别。 JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境，JDK中包含了JRE。 JRE是Java的运行环境，是面向所有Java程序的使用者，包括开发者。 JRE = 运行环境 = JVM。 如果安装了JDK，会发现电脑中有两套JRE，一套位于/Java/jre…/下，一套位于/Java/jdk…/jre下。那么问题来了，一台机器上有两套以上JRE，谁来决定运行那一套呢？这个任务就落到java.exe身上，java.exe的任务就是找到合适的JRE来运行java程序。java.exe按照以下的顺序来选择JRE： 1、自己目录下有没有JRE 2、父目录下有没有JRE 3、查询注册表： HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment\”当前JRE版本号”\JavaHome 这几步的主要核心是为了找到JVM的绝对路径。 jvm.cfg的路径为：JRE路径\lib\”CPU架构”\jvm.fig我自己打开了自己的jvm.cfg文件KNOWN 表示存在 、IGNORE 表示不存在 、ALIASED_TO 表示给别的JVM去一个别名WARN 表示不存在时找一个替代 、ERROR 表示不存在抛出异常 这里面记载的是可用的jvm，也就是jvm执行文件jvm.dll的文件所在位置，你可以自行搜索jvm.dll，就可以看到它在client和server下都有个jvm.dll 通过第一步找到JVM的路径后，Java.exe通过LoadJavaVM来装入JVM文件。LoadLibrary装载JVM动态连接库，然后把JVM中的到处函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMIntArgs 挂接到InvocationFunction 变量的CreateJavaVM和GetDafaultJavaVMInitArgs 函数指针变量上。JVM的装载工作完成。 在装载完虚拟机之后，我们得把class文件给放入虚拟机中运行,这时候会用到JNI.JNI是JAVA本地接口,它就是从本地找到需要运行的class文件放入JVM的接口(它也常用于java与操作系统或硬件的交互)。class装载进去后，找到main方法，执行文件。 二.基本结构经过上面粗略的介绍之后，我们了解到，class文件经过一系列的步骤之后，被加载进了jvm，那进入jvm之后它又怎样了？大致是解释成了如下结构: 其中要学习的重点是内存空间，PC寄存器和垃圾回收器。 方法区方法区是一个堆结构的存储区域，但是它又被称为Non-Heap(非堆)，这样是为了和java堆结构区分开来。这是个线程共享的区域，用于存储已经被jvm加载完的类信息，常量，静态变量和即时编译器编译后的代码等数据。在HotSpot虚拟机中，常常把方法区称作是“永久代”。但它只是HotSpot在实现方法区的时候用了永久代，这样做是为了垃圾回收器能够对这里回收。但是1.8之后都不是这样做了，这里只做了解。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。 堆这里是java容易发生oom错误的地方，因为这里存储的是实例化之后的类对象和数组。这是一个线程共享的内存区域，在虚拟机启动的时候创建。java堆是数据更迭最多的地方也就是垃圾回收器主要的存在地点，所以它也被称为GC堆。GC堆大致分为新生代和老年代，新生代在分代垃圾回收器中分为Eden空间、From Survivor、To Survivor空间等。这样是为了更快更高效的回收垃圾，在之后章节做出更多分析。 虚拟机栈jvm中有两个栈，一个是虚拟机栈，另一个是本地方法栈。我们先讲虚拟机栈，这个是线程私有的，每有一个线程就创建一个栈，每执行一个方法就往里面加一个栈帧，栈帧里面存储的是局部变量表，操作数栈，动态链接，返回地址等。 局部变量表主要存放了编译器可知的变量类型(byte,double,int,float,char,short,boolean,long)和对象引用(对象的地址,其一是指向对象的起始地址，另一是指向一个句柄或其他与其相关的引用) 操作数栈操作数栈是一个先入后出栈，是方法进行时进行算数运算或者是在调用其他方法时传递参数的时候起作用的。 动态链接每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。 返回地址 当一个方法开始执行以后，只有两种方法可以退出当前方法： 当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口（Normal Method Invocation Completion），一般来说，调用者的PC计数器可以作为返回地址。 当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，称为异常完成出口（Abrupt Method Invocation Completion），返回地址要通过异常处理器表来确定。 当方法返回时，可能进行3个操作： 恢复上层方法的局部变量表和操作数栈 把返回值压入调用者调用者栈帧的操作数栈 调整 PC 计数器的值以指向方法调用指令后面的一条指令 本地方法栈 本地方法栈角色和java栈类似，只不过它是用来表示执行本地方法的，本地方法栈存放的方法调用本地方法接口，最终调用本地方法库，实现与操作系统、硬件交互的目的。区别是： 虚拟机栈为虚拟机执行Java方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 在HotSpot虚拟机中和Java虚拟机栈合二为一。 PC寄存器PC寄存器还叫程序计数器。程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 直接内存直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。 JDK1.4中新加入的NIO(New Input/Output)类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的I/O方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在Java堆和Native堆之间来回复制数据。 本机直接内存的分配不会收到Java堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。 常量池运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用） 既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。 JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。同时在 jdk 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域 元空间其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。 永久代被元空间取代的原因： 字符串存在永久代中，容易出现性能问题和内存溢出。 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。 Oracle 可能会将HotSpot 与 JRockit 合二为一。 关于此篇博客 这篇博客是为了学习jvm的原理，主要是学习它的内存分布，上面基本都讲全了，但是里面提到的两个东西得分开讲，一个是常量池，另一个是GC。 引用博客 Java面试通关手册 –Snailclimb 深入理解JVM–飘扬的红岭巾Java8内存模型—永久代(PermGen)和元空间(Metaspace)深入理解java虚拟机（十） Java 虚拟机运行时栈帧结构]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F08%2F28%2Farithmetic%2F</url>
    <content type="text"><![CDATA[排序算法排序算法是将同一类无序或有序的数据排列成自己特定顺序的一系列算法，一般情况是排列成升序或是降序。本篇博客将介绍八种排序算法 该篇博客基本是向其他博主借鉴学习，借用其他博主的图片为学习所用，在博客底部会注明图片来源 一.插入排序算法原理插入算法是一种简单的排序算法,把无序的先排序成有序的，再将其他单个元素一个一个插入到有序序列中，找到相应的位置，然后放置到相应位置。 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。 代码实现(java)1234567891011121314static void inSpace(int[] a)&#123;//插入排序，就是把这个之前的当做已经排好的，然后插入到前面去 int j,temp; if (a.length &lt;= 2)return; for(int i = 0;i&lt;a.length-1;i++)&#123; j=i+1; temp = a[j]; while(j&gt;=1 &amp;&amp; temp&lt;a[j-1])&#123;//先判断长度在比大小防止越界 a[j]=a[j-1];//往右让出一个位置 j--;//j指向这个位置如果条件不符合就是这里 &#125; a[j]=temp;//temp和j指向的位置调换 &#125; //for(int i:a)System.out.println(i); &#125; 算法示意图 二.希尔排序算法原理 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率 但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 算法步骤 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 代码实现(c++)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define MAXNUM 10void main()&#123; void shellSort(int array[],int n,int t);//t为排序趟数 int array[MAXNUM],i; for(i = 0;i &lt; MAXNUM;i++) scanf("%d",&amp;array[i]); shellSort(array,MAXNUM,int(log(MAXNUM + 1) / log(2)));//排序趟数应为log2(n+1)的整数部分 for(i = 0;i &lt; MAXNUM;i++) printf("%d ",array[i]); printf("\n");&#125;//根据当前增量进行插入排序void shellInsert(int array[],int n,int dk)&#123; int i,j,temp; for(i = dk;i &lt; n;i++)//分别向每组的有序区域插入 &#123; temp = array[i]; for(j = i-dk;(j &gt;= i % dk) &amp;&amp; array[j] &gt; temp;j -= dk)//比较与记录后移同时进行 array[j + dk] = array[j]; if(j != i - dk) array[j + dk] = temp;//插入 &#125;&#125;//计算Hibbard增量int dkHibbard(int t,int k)&#123; return int(pow(2,t - k + 1) - 1);&#125;//希尔排序void shellSort(int array[],int n,int t)&#123; void shellInsert(int array[],int n,int dk); int i; for(i = 1;i &lt;= t;i++) shellInsert(array,n,dkHibbard(t,i));&#125;//此写法便于理解，实际应用时应将上述三个函数写成一个函数。 算法示意图 三.选择排序算法原理选择排序其实是日常的常见的排序，在无序的序列中找出第一小的，然后找出第二小的，以此类推，到最后就按顺序排好了 算法步骤 选取第一个位置作为参照 循环找剩下序列(包括参照位置)中最小的 与参照位置互换 进行下一个位置的排序 代码实现(java)12345678910static void selectSort(int[] a)&#123;//选择排序，把第i个数值换成是i(包括i)之后的序列中最小的 for (int i = 0; i &lt; a.length-1; i++) &#123; int min=i;//包括i,假设i是最小的 for (int j = i+1; j &lt; a.length ; j++) &#123; if (a[j]&lt;a[min])min=j;//冒泡 &#125; swap(a,i,min); &#125; //for(int i:a)System.out.println(i);&#125; 算法示意图 四.冒泡排序算法原理冒泡排序和选择排序其实很像，只不过实现方式不一样，冒泡排序是从起始位置开始，往后纠正相邻位置的顺序并交换。在第一个参照的遍历后，就能找出最大的并放在最末尾，第二次之后第二大的到了倒数第二的位置，以此类推就排序完了。 算法步骤以第一个为参照，往后交换并比较，做整个序列的遍历就行了 代码实现(java)12345678static void popSort(int[] a)&#123;//冒泡排序 for (int i = 0; i &lt; a.length-2; i++) &#123; for (int j = a.length-1; j &gt; i; j--) &#123; if (a[j]&lt;a[j-1])swap(a,j,j-1);//冒泡 &#125; &#125; //for(int i:a)System.out.println(i);&#125; 算法示意图 五.归并排序算法原理归并排序是先分割再整合的算法，重点在于整合部分，归并排序先把整个序列分割成最小的有序序列，一般情况下最后的分割方式下都是分割成单个数值，然后合并成有序数列。合并时，进行合并的时候两个数列必定为有序的，因为它是从之前的小的序列进行有序的合并之后得到的，往前推就是单个数字，所以我们保证了进行一次合并的时候两个序列一定有序。然后创建一个序列，取两个序列的起始位置作为比较参照位的数值，更小的那个参照位置则赋值给新的序列，被取走数值的那个序列参照位往后移动一位。直到一个序列的最后一位被取完，则停止比较，把还剩余数值的序列赋值给新序列（一位一位往后移动，因为是有序的）。这个过程很重要，先确定它一定有序后，直接按着两个序列下标来往后移动，往新序列插入的过程就是排序的过程，分解后归并就完成了排序 算法步骤 递归分解序列成一个一个的小序列 把小序列一个一个的合并成大序列 合并的时候按照下标顺序进行比较，然后插入新序列 代码实现(java)12345678910111213141516171819202122232425262728//归并排序 start static void mergeSortAdd(int[] a,int left ,int mid,int right )&#123; int i = left,n = mid; int j = mid+1,m = right; int t=0; int[] b = new int[right-left+1]; while(i&lt;=n &amp;&amp; j&lt;=m)&#123; if (a[i]&lt;=a[j]) b[t++] = a[i++]; else b[t++] = a[j++]; &#125; while(i&lt;=n) b[t++] = a[i++]; while(j&lt;=m) b[t++] = a[j++]; for (int k = left,l = 0; k &lt;= right; k++,l++) a[k] = b[l]; &#125; static void mergeSort(int a[],int left,int right)&#123; if (left&lt;right)&#123;//基本都是拆分成单个数字，因为你无法确定两个数字的小数组是否有序 int mid = (left+right)/2; mergeSort(a,left,mid); mergeSort(a,mid+1,right); mergeSortAdd(a,left,mid,right); &#125; &#125; //归并排序 end 算法示意图 六.快速排序算法原理上面提到的归并算法中有个思想是分治，把一个大的个体分成一个个小的个体进行比较，快速排序也是利用了分治的思想。快速排序就像是做一个筛选，把大的放左边，小的放右边，加上分治的思想，分割到最小模块的时候，两个数值的序列，小的和大的分在两边就是有序的。快速排序先把比参照位小的放左边，大的放右边，这个操作保证了左边所有的都小于右边，所以当左右都排序好的时候，整个序列都是有序的。我们再把左边作为一整个序列进行快速排序，直至分割到最小的序列整个序列都是有序的。 算法步骤 取第一个作为参照位置，把整个序列分成大小两边 把其中一边再作为进行快速排序的序列，取其第一个数值作为参照位置分成大小两边 由此递归下去整个数组都是有序的 代码实现(java)123456789101112131415161718static void speedSort(int[] a,int left ,int right)&#123;//快速排序 if(left&lt;right)&#123; int temp = a[left]; int i = left; int j = right; while (i&lt;j)&#123; while (i&lt;j &amp;&amp; a[i]&lt;=temp) i++; while(i&lt;j &amp;&amp; a[j]&gt;=temp) j--; if(i&lt;j) swap(a,i,j); &#125; if(a[i]&gt;temp) i--; swap(a,i,left); speedSort(a,left,i-1); speedSort(a,i+1,right); &#125;&#125; 算法示意图 七.堆排序算法原理堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。先把整个序列整理成一个大顶堆，然后把堆顶的数值放到最末尾，在下次重排序的时候不包括进去，由此把第二大的放在了堆顶，把堆顶和倒数第二个进行置换，如此循环到最后就排序完了。每次的排序就是父节点和两个儿子的三选一(在叶子的时候可能只有一个儿子)把最大的放到顶部(类似分治)全部循环一边就把最大的挑选到顶部了，这个排序的过程需要有个前提就是这棵树是小顶堆，所以每次都能找到最大的。 算法步骤 把整个序列整理成一个完全二叉树 再整理成小顶堆 开始把最大的放到堆顶后置换到最后一位，再进行除已排序的序列的排序，遍历完整个数组之后即可完成排序 代码实现(java)1234567891011121314151617181920212223 //堆排序 start static void heapSort(int[] a,int i,int length)&#123; int left = i*2+1; int right = i*2+2; int largest; if(left &lt; length &amp;&amp; a[left]&gt;a[i])largest = left; else largest = i; if(right&lt; length &amp;&amp; a[right]&gt;a[largest])largest = right;//这里最容易出错，要和最大的比较而不是和父节点比较 if (largest!=i)&#123;//如果找到子节点有最大值，交换后把子节点的位置做新的堆下沉 swap(a,largest,i); heapSort(a,largest,length); &#125; &#125; static void heapSortStart(int[] a)&#123; for (int i = (a.length)/2; i &gt;= 0 ; i--) heapSort(a,i,a.length);//创建小顶堆，从中间向上整理 for (int i = a.length-1; i &gt;=0; i--) &#123; swap(a,0,i);//栈顶拿来存已经整理的数据 heapSort(a,0,i); &#125;// for(int i:a)System.out.print(" "+i); &#125; // 堆排序 end 算法示意图 八.计数排序算法原理这个其实特别简单的，本应该写在前面的，但是这个顺序我也是随便写的。计数排序就是计数，比如范围是1-10 序列是[2,8]，在计数器中第二位和第八位加个一，按照计数器的顺序进行遍历，计数器有多少数值就输出多少次。(我觉得使用的场景少，了解一下就ok了) 算法步骤 创建一个计数器数组，取决于数组中的最大数值(关键就在这里，万一排个[5,1,99999999]这计数器就太浪费了) 遍历序列，把数值作为计数器的下标，计数器数值加一 按照计数器的遍历顺序放回序列中 代码实现(js)12345678910111213141516171819202122function countingSort(arr, maxValue) &#123; var bucket = new Array(maxValue + 1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++; &#125; for (var j = 0; j &lt; bucketLen; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr;&#125; 算法示意图 九.桶排序算法原理桶排序就是把一个范围的数值放进桶里排序，其实有点像快速排序，快速排序是二分的分治的，而桶排序就是蠢蠢的分了一次。如果桶的数量是十，就意味着把这个序列的数值最大不能大于100(这里是我的理解),先把十位数相同的放进每个桶里，然后桶里进行排序之后再按照十位数放回序列里。 算法步骤 设置一个定量的数组当作空桶 遍历输入数据，并且把数据一个一个放到对应的桶里去 对每个不是空的桶进行排序 从不是空的桶里把排好序的数据拼接起来。 代码实现(js)12345678910111213141516171819202122232425262728293031323334353637383940function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; // 输入数据的最小值 &#125; else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; // 输入数据的最大值 &#125; &#125; // 桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; // 利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr;&#125; 算法示意图 十.基数排序算法原理基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法步骤 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 代码实现(js)123456789101112131415161718192021222324var counter = [];function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; return arr;&#125; 算法示意图 算法复杂度这只是部分的 关于此篇博客 希尔排序我感觉一般所以直接搬用了其他博主的代码与解析，其原理和实现我都自己做了。最后三个排序我感觉蠢蠢的但是肯定也有它们的应用场景，实现起来也特简单，所以我就直接搬用了其他博主的博客内容。整个博客其实就是自己学习所用，来试试自己学的怎样了，结果感觉还行。整个博客都是用自己的通俗的理解写出来的，主要是为了给自己复习，写的易懂一些，所以肯定很不严谨，欢迎各位的批评指正，我会及时修改。 引用博客 https://www.cnblogs.com/RainyBear/p/5258483.htmlhttps://www.cnblogs.com/onepixel/articles/7674659.html]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my blog]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>centOS</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
</search>
