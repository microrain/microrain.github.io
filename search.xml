<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[学习java虚拟机(三): 垃圾回收机制]]></title>
    <url>%2F2018%2F09%2F05%2Fjvmthree%2F</url>
    <content type="text"><![CDATA[123]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习java虚拟机(二): 常量池]]></title>
    <url>%2F2018%2F09%2F05%2Fjvmtwo%2F</url>
    <content type="text"><![CDATA[学习java虚拟机(二): 常量池上节讲到jvm基础的内存分布中，有个部分叫常量池，这里是一个特别的部分，而且有些时候会问到，所以单独做一个模块来讲 该篇博客基本是向其他博主借鉴学习，借用其他博主的图片为学习所用，在博客底部会注明图片来源 一.基本概念虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和floating point常量）和对其他类型，字段和方法的符号引用。对于String常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的，对于String类型，有一张固定长度的CONSTANT_String_info表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。 二.基本类型Java 基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean；这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。 123456789Integer a = 33;Integer b = 33;System.out.println(a == b)//输出trueInteger c = 333;Integer d = 333;System.out.println(c == d)//输出falseDouble e = 1.2;Double f = 1.2;System.out.println(e == f)//输出false 我们可以看Integer的缓存源代码12345public static Integer valueOf(int i)&#123; if(i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i+(-IntegerCache.low)]; return new Ingeter(i);&#125; 应用场景 Integer i1=40；Java在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。 Integer i1 = new Integer(40);这种情况下会创建新的对象，所以尽量避免使用这种方式。123Ingeter i1 = 40;Ingeter i2 = new Ingeter(40);System.out.println(i1 == i2);//返回false 全部例子12345678910111213Integer i1 = 40;Integer i2 = 40;Integer i3 = 0;Integer i4 = new Integer(40);Integer i5 = new Integer(40);Integer i6 = new Integer(0);System.out.println("i1=i2 " + (i1 == i2));//trueSystem.out.println("i1=i2+i3 " + (i1 == i2 + i3));//trueSystem.out.println("i1=i4 " + (i1 == i4));//falseSystem.out.println("i4=i5 " + (i4 == i5));//falseSystem.out.println("i4=i5+i6 " + (i4 == i5 + i6));//true System.out.println("40=i5+i6 " + (40 == i5 + i6));//true 部分解释:语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终这条语句转为40 == 40进行数值比较。 三.String 类1.String的两种创建方式：123String str1 = "abcd";String str2 = new String("abcd");System.out.println(str1==str2);//false 这两种不同的创建方法是有差别的，第一种方式是在常量池中拿对象，第二种方式是直接在堆内存空间创建一个新的对象。 只要使用new方法，便需要创建新的对象。 String类型的常量池比较特殊。它的主要使用方法有两种： 直接使用双引号声明出来的String对象会直接存储在常量池中。 如果不是用双引号声明的String对象，可以使用String提供的intern方String.intern() 是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用。 123456String s1 = new String("计算机");String s2 = s1.intern();String s3 = "计算机";System.out.println(s2);//计算机System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，System.out.println(s3 == s2);//true，因为两个都是常量池中的String对 String字符串拼接 尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的花，可以使用 StringBuilder 或者 StringBuffer。 123456String str3 = "str" + "ing";//常量池中的对象String str4 = str1 + str2; //在堆上创建的新的对象 String str5 = "string";//常量池中的对象System.out.println(str3 == str4);//falseSystem.out.println(str3 == str5);//trueSystem.out.println(str4 == str5);//false String s1 = new String(“abc”);这句话创建了几个对象？创建了两个对象。1234String s1 = new String("abc");// 堆内存的地值值String s2 = "abc";System.out.println(s1 == s2);// 输出false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。System.out.println(s1.equals(s2));// 输出true 解释：先有字符串”abc”放入常量池，然后 new 了一份字符串”abc”放入Java堆(字符串常量”abc”在编译期就已经确定放入常量池，而 Java 堆上的”abc”是在运行期初始化阶段才确定)，然后 Java 栈的 str1 指向Java堆上的”abc”。 关于此篇博客 这篇博客大部分是复制别的博客的内容，这篇博客主要目的是复制记忆这部分知识，因为这部分知识不难，代码都是自己测试了并且手打的，把这篇博客放在这里是为了下次复习可用。 引用博客 Java面试通关手册 –Snailclimb]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习java虚拟机(一): 基础原理]]></title>
    <url>%2F2018%2F09%2F04%2Fjvmone%2F</url>
    <content type="text"><![CDATA[学习java虚拟机(一): 基础原理java虚拟机简称jvm，该部分知识是学习java比较重要的一部分，如果要深入java进行研究学习，那jvm就是入门的标准。 该篇博客基本是向其他博主借鉴学习，借用其他博主的图片为学习所用，在博客底部会注明图片来源 一.运行流程java一直以来的口号都是一次编译处处运行,在编译java文件成class文件之后，就可以在任何拥有java虚拟机的机器上运行。该虚拟机会将该class文件进行编译，转换成机器码让机器识别,最终就可以被运行。当jvm得到class文件之后又进行了哪些步骤？首先，jvm会去寻找在系统中的jvm.cfg文件，然后从文件中读取你所选择的虚拟机。 在学习这个之前，我们需要了解一件事情，就是JDK和JRE的区别。 JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境，JDK中包含了JRE。 JRE是Java的运行环境，是面向所有Java程序的使用者，包括开发者。 JRE = 运行环境 = JVM。 如果安装了JDK，会发现电脑中有两套JRE，一套位于/Java/jre…/下，一套位于/Java/jdk…/jre下。那么问题来了，一台机器上有两套以上JRE，谁来决定运行那一套呢？这个任务就落到java.exe身上，java.exe的任务就是找到合适的JRE来运行java程序。java.exe按照以下的顺序来选择JRE： 1、自己目录下有没有JRE 2、父目录下有没有JRE 3、查询注册表： HKEY_LOCAL_MACHINE\SOFTWARE\JavaSoft\Java Runtime Environment\”当前JRE版本号”\JavaHome 这几步的主要核心是为了找到JVM的绝对路径。 jvm.cfg的路径为：JRE路径\lib\”CPU架构”\jvm.fig我自己打开了自己的jvm.cfg文件KNOWN 表示存在 、IGNORE 表示不存在 、ALIASED_TO 表示给别的JVM去一个别名WARN 表示不存在时找一个替代 、ERROR 表示不存在抛出异常 这里面记载的是可用的jvm，也就是jvm执行文件jvm.dll的文件所在位置，你可以自行搜索jvm.dll，就可以看到它在client和server下都有个jvm.dll 通过第一步找到JVM的路径后，Java.exe通过LoadJavaVM来装入JVM文件。LoadLibrary装载JVM动态连接库，然后把JVM中的到处函数JNI_CreateJavaVM和JNI_GetDefaultJavaVMIntArgs 挂接到InvocationFunction 变量的CreateJavaVM和GetDafaultJavaVMInitArgs 函数指针变量上。JVM的装载工作完成。 在装载完虚拟机之后，我们得把class文件给放入虚拟机中运行,这时候会用到JNI.JNI是JAVA本地接口,它就是从本地找到需要运行的class文件放入JVM的接口(它也常用于java与操作系统或硬件的交互)。class装载进去后，找到main方法，执行文件。 二.基本结构经过上面粗略的介绍之后，我们了解到，class文件经过一系列的步骤之后，被加载进了jvm，那进入jvm之后它又怎样了？大致是解释成了如下结构: 其中要学习的重点是内存空间，PC寄存器和垃圾回收器。 方法区方法区是一个堆结构的存储区域，但是它又被称为Non-Heap(非堆)，这样是为了和java堆结构区分开来。这是个线程共享的区域，用于存储已经被jvm加载完的类信息，常量，静态变量和即时编译器编译后的代码等数据。在HotSpot虚拟机中，常常把方法区称作是“永久代”。但它只是HotSpot在实现方法区的时候用了永久代，这样做是为了垃圾回收器能够对这里回收。但是1.8之后都不是这样做了，这里只做了解。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。 堆这里是java容易发生oom错误的地方，因为这里存储的是实例化之后的类对象和数组。这是一个线程共享的内存区域，在虚拟机启动的时候创建。java堆是数据更迭最多的地方也就是垃圾回收器主要的存在地点，所以它也被称为GC堆。GC堆大致分为新生代和老年代，新生代在分代垃圾回收器中分为Eden空间、From Survivor、To Survivor空间等。这样是为了更快更高效的回收垃圾，在之后章节做出更多分析。 虚拟机栈jvm中有两个栈，一个是虚拟机栈，另一个是本地方法栈。我们先讲虚拟机栈，这个是线程私有的，每有一个线程就创建一个栈，每执行一个方法就往里面加一个栈帧，栈帧里面存储的是局部变量表，操作数栈，动态链接，返回地址等。 局部变量表主要存放了编译器可知的变量类型(byte,double,int,float,char,short,boolean,long)和对象引用(对象的地址,其一是指向对象的起始地址，另一是指向一个句柄或其他与其相关的引用) 操作数栈操作数栈是一个先入后出栈，是方法进行时进行算数运算或者是在调用其他方法时传递参数的时候起作用的。 动态链接每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。 返回地址 当一个方法开始执行以后，只有两种方法可以退出当前方法： 当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口（Normal Method Invocation Completion），一般来说，调用者的PC计数器可以作为返回地址。 当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，称为异常完成出口（Abrupt Method Invocation Completion），返回地址要通过异常处理器表来确定。 当方法返回时，可能进行3个操作： 恢复上层方法的局部变量表和操作数栈 把返回值压入调用者调用者栈帧的操作数栈 调整 PC 计数器的值以指向方法调用指令后面的一条指令 本地方法栈 本地方法栈角色和java栈类似，只不过它是用来表示执行本地方法的，本地方法栈存放的方法调用本地方法接口，最终调用本地方法库，实现与操作系统、硬件交互的目的。区别是： 虚拟机栈为虚拟机执行Java方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。 在HotSpot虚拟机中和Java虚拟机栈合二为一。 PC寄存器PC寄存器还叫程序计数器。程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。 另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 直接内存直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。 JDK1.4中新加入的NIO(New Input/Output)类，引入了一种基于通道（Channel） 与缓存区（Buffer） 的I/O方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在Java堆和Native堆之间来回复制数据。 本机直接内存的分配不会收到Java堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。 常量池运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用） 既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。 JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。同时在 jdk 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域 元空间其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。 永久代被元空间取代的原因： 字符串存在永久代中，容易出现性能问题和内存溢出。 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。 Oracle 可能会将HotSpot 与 JRockit 合二为一。 关于此篇博客 这篇博客是为了学习jvm的原理，主要是学习它的内存分布，上面基本都讲全了，但是里面提到的两个东西得分开讲，一个是常量池，另一个是GC。 引用博客 Java面试通关手册 –Snailclimb 深入理解JVM–飘扬的红岭巾Java8内存模型—永久代(PermGen)和元空间(Metaspace)深入理解java虚拟机（十） Java 虚拟机运行时栈帧结构]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F08%2F28%2Farithmetic%2F</url>
    <content type="text"><![CDATA[排序算法排序算法是将同一类无序或有序的数据排列成自己特定顺序的一系列算法，一般情况是排列成升序或是降序。本篇博客将介绍八种排序算法 该篇博客基本是向其他博主借鉴学习，借用其他博主的图片为学习所用，在博客底部会注明图片来源 一.插入排序算法原理插入算法是一种简单的排序算法,把无序的先排序成有序的，再将其他单个元素一个一个插入到有序序列中，找到相应的位置，然后放置到相应位置。 算法步骤 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。 代码实现(java)1234567891011121314static void inSpace(int[] a)&#123;//插入排序，就是把这个之前的当做已经排好的，然后插入到前面去 int j,temp; if (a.length &lt;= 2)return; for(int i = 0;i&lt;a.length-1;i++)&#123; j=i+1; temp = a[j]; while(j&gt;=1 &amp;&amp; temp&lt;a[j-1])&#123;//先判断长度在比大小防止越界 a[j]=a[j-1];//往右让出一个位置 j--;//j指向这个位置如果条件不符合就是这里 &#125; a[j]=temp;//temp和j指向的位置调换 &#125; //for(int i:a)System.out.println(i); &#125; 算法示意图 二.希尔排序算法原理 希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。 希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率 但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位 希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 算法步骤 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 代码实现(c++)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define MAXNUM 10void main()&#123; void shellSort(int array[],int n,int t);//t为排序趟数 int array[MAXNUM],i; for(i = 0;i &lt; MAXNUM;i++) scanf("%d",&amp;array[i]); shellSort(array,MAXNUM,int(log(MAXNUM + 1) / log(2)));//排序趟数应为log2(n+1)的整数部分 for(i = 0;i &lt; MAXNUM;i++) printf("%d ",array[i]); printf("\n");&#125;//根据当前增量进行插入排序void shellInsert(int array[],int n,int dk)&#123; int i,j,temp; for(i = dk;i &lt; n;i++)//分别向每组的有序区域插入 &#123; temp = array[i]; for(j = i-dk;(j &gt;= i % dk) &amp;&amp; array[j] &gt; temp;j -= dk)//比较与记录后移同时进行 array[j + dk] = array[j]; if(j != i - dk) array[j + dk] = temp;//插入 &#125;&#125;//计算Hibbard增量int dkHibbard(int t,int k)&#123; return int(pow(2,t - k + 1) - 1);&#125;//希尔排序void shellSort(int array[],int n,int t)&#123; void shellInsert(int array[],int n,int dk); int i; for(i = 1;i &lt;= t;i++) shellInsert(array,n,dkHibbard(t,i));&#125;//此写法便于理解，实际应用时应将上述三个函数写成一个函数。 算法示意图 三.选择排序算法原理选择排序其实是日常的常见的排序，在无序的序列中找出第一小的，然后找出第二小的，以此类推，到最后就按顺序排好了 算法步骤 选取第一个位置作为参照 循环找剩下序列(包括参照位置)中最小的 与参照位置互换 进行下一个位置的排序 代码实现(java)12345678910static void selectSort(int[] a)&#123;//选择排序，把第i个数值换成是i(包括i)之后的序列中最小的 for (int i = 0; i &lt; a.length-1; i++) &#123; int min=i;//包括i,假设i是最小的 for (int j = i+1; j &lt; a.length ; j++) &#123; if (a[j]&lt;a[min])min=j;//冒泡 &#125; swap(a,i,min); &#125; //for(int i:a)System.out.println(i);&#125; 算法示意图 四.冒泡排序算法原理冒泡排序和选择排序其实很像，只不过实现方式不一样，冒泡排序是从起始位置开始，往后纠正相邻位置的顺序并交换。在第一个参照的遍历后，就能找出最大的并放在最末尾，第二次之后第二大的到了倒数第二的位置，以此类推就排序完了。 算法步骤以第一个为参照，往后交换并比较，做整个序列的遍历就行了 代码实现(java)12345678static void popSort(int[] a)&#123;//冒泡排序 for (int i = 0; i &lt; a.length-2; i++) &#123; for (int j = a.length-1; j &gt; i; j--) &#123; if (a[j]&lt;a[j-1])swap(a,j,j-1);//冒泡 &#125; &#125; //for(int i:a)System.out.println(i);&#125; 算法示意图 五.归并排序算法原理归并排序是先分割再整合的算法，重点在于整合部分，归并排序先把整个序列分割成最小的有序序列，一般情况下最后的分割方式下都是分割成单个数值，然后合并成有序数列。合并时，进行合并的时候两个数列必定为有序的，因为它是从之前的小的序列进行有序的合并之后得到的，往前推就是单个数字，所以我们保证了进行一次合并的时候两个序列一定有序。然后创建一个序列，取两个序列的起始位置作为比较参照位的数值，更小的那个参照位置则赋值给新的序列，被取走数值的那个序列参照位往后移动一位。直到一个序列的最后一位被取完，则停止比较，把还剩余数值的序列赋值给新序列（一位一位往后移动，因为是有序的）。这个过程很重要，先确定它一定有序后，直接按着两个序列下标来往后移动，往新序列插入的过程就是排序的过程，分解后归并就完成了排序 算法步骤 递归分解序列成一个一个的小序列 把小序列一个一个的合并成大序列 合并的时候按照下标顺序进行比较，然后插入新序列 代码实现(java)12345678910111213141516171819202122232425262728//归并排序 start static void mergeSortAdd(int[] a,int left ,int mid,int right )&#123; int i = left,n = mid; int j = mid+1,m = right; int t=0; int[] b = new int[right-left+1]; while(i&lt;=n &amp;&amp; j&lt;=m)&#123; if (a[i]&lt;=a[j]) b[t++] = a[i++]; else b[t++] = a[j++]; &#125; while(i&lt;=n) b[t++] = a[i++]; while(j&lt;=m) b[t++] = a[j++]; for (int k = left,l = 0; k &lt;= right; k++,l++) a[k] = b[l]; &#125; static void mergeSort(int a[],int left,int right)&#123; if (left&lt;right)&#123;//基本都是拆分成单个数字，因为你无法确定两个数字的小数组是否有序 int mid = (left+right)/2; mergeSort(a,left,mid); mergeSort(a,mid+1,right); mergeSortAdd(a,left,mid,right); &#125; &#125; //归并排序 end 算法示意图 六.快速排序算法原理上面提到的归并算法中有个思想是分治，把一个大的个体分成一个个小的个体进行比较，快速排序也是利用了分治的思想。快速排序就像是做一个筛选，把大的放左边，小的放右边，加上分治的思想，分割到最小模块的时候，两个数值的序列，小的和大的分在两边就是有序的。快速排序先把比参照位小的放左边，大的放右边，这个操作保证了左边所有的都小于右边，所以当左右都排序好的时候，整个序列都是有序的。我们再把左边作为一整个序列进行快速排序，直至分割到最小的序列整个序列都是有序的。 算法步骤 取第一个作为参照位置，把整个序列分成大小两边 把其中一边再作为进行快速排序的序列，取其第一个数值作为参照位置分成大小两边 由此递归下去整个数组都是有序的 代码实现(java)123456789101112131415161718static void speedSort(int[] a,int left ,int right)&#123;//快速排序 if(left&lt;right)&#123; int temp = a[left]; int i = left; int j = right; while (i&lt;j)&#123; while (i&lt;j &amp;&amp; a[i]&lt;=temp) i++; while(i&lt;j &amp;&amp; a[j]&gt;=temp) j--; if(i&lt;j) swap(a,i,j); &#125; if(a[i]&gt;temp) i--; swap(a,i,left); speedSort(a,left,i-1); speedSort(a,i+1,right); &#125;&#125; 算法示意图 七.堆排序算法原理堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。先把整个序列整理成一个大顶堆，然后把堆顶的数值放到最末尾，在下次重排序的时候不包括进去，由此把第二大的放在了堆顶，把堆顶和倒数第二个进行置换，如此循环到最后就排序完了。每次的排序就是父节点和两个儿子的三选一(在叶子的时候可能只有一个儿子)把最大的放到顶部(类似分治)全部循环一边就把最大的挑选到顶部了，这个排序的过程需要有个前提就是这棵树是小顶堆，所以每次都能找到最大的。 算法步骤 把整个序列整理成一个完全二叉树 再整理成小顶堆 开始把最大的放到堆顶后置换到最后一位，再进行除已排序的序列的排序，遍历完整个数组之后即可完成排序 代码实现(java)1234567891011121314151617181920212223 //堆排序 start static void heapSort(int[] a,int i,int length)&#123; int left = i*2+1; int right = i*2+2; int largest; if(left &lt; length &amp;&amp; a[left]&gt;a[i])largest = left; else largest = i; if(right&lt; length &amp;&amp; a[right]&gt;a[largest])largest = right;//这里最容易出错，要和最大的比较而不是和父节点比较 if (largest!=i)&#123;//如果找到子节点有最大值，交换后把子节点的位置做新的堆下沉 swap(a,largest,i); heapSort(a,largest,length); &#125; &#125; static void heapSortStart(int[] a)&#123; for (int i = (a.length)/2; i &gt;= 0 ; i--) heapSort(a,i,a.length);//创建小顶堆，从中间向上整理 for (int i = a.length-1; i &gt;=0; i--) &#123; swap(a,0,i);//栈顶拿来存已经整理的数据 heapSort(a,0,i); &#125;// for(int i:a)System.out.print(" "+i); &#125; // 堆排序 end 算法示意图 八.计数排序算法原理这个其实特别简单的，本应该写在前面的，但是这个顺序我也是随便写的。计数排序就是计数，比如范围是1-10 序列是[2,8]，在计数器中第二位和第八位加个一，按照计数器的顺序进行遍历，计数器有多少数值就输出多少次。(我觉得使用的场景少，了解一下就ok了) 算法步骤 创建一个计数器数组，取决于数组中的最大数值(关键就在这里，万一排个[5,1,99999999]这计数器就太浪费了) 遍历序列，把数值作为计数器的下标，计数器数值加一 按照计数器的遍历顺序放回序列中 代码实现(js)12345678910111213141516171819202122function countingSort(arr, maxValue) &#123; var bucket = new Array(maxValue + 1), sortedIndex = 0; arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]]++; &#125; for (var j = 0; j &lt; bucketLen; j++) &#123; while(bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j]--; &#125; &#125; return arr;&#125; 算法示意图 九.桶排序算法原理桶排序就是把一个范围的数值放进桶里排序，其实有点像快速排序，快速排序是二分的分治的，而桶排序就是蠢蠢的分了一次。如果桶的数量是十，就意味着把这个序列的数值最大不能大于100(这里是我的理解),先把十位数相同的放进每个桶里，然后桶里进行排序之后再按照十位数放回序列里。 算法步骤 设置一个定量的数组当作空桶 遍历输入数据，并且把数据一个一个放到对应的桶里去 对每个不是空的桶进行排序 从不是空的桶里把排好序的数据拼接起来。 代码实现(js)12345678910111213141516171819202122232425262728293031323334353637383940function bucketSort(arr, bucketSize) &#123; if (arr.length === 0) &#123; return arr; &#125; var i; var minValue = arr[0]; var maxValue = arr[0]; for (i = 1; i &lt; arr.length; i++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i]; // 输入数据的最小值 &#125; else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i]; // 输入数据的最大值 &#125; &#125; // 桶的初始化 var DEFAULT_BUCKET_SIZE = 5; // 设置桶的默认数量为5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE; var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1; var buckets = new Array(bucketCount); for (i = 0; i &lt; buckets.length; i++) &#123; buckets[i] = []; &#125; // 利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]); &#125; arr.length = 0; for (i = 0; i &lt; buckets.length; i++) &#123; insertionSort(buckets[i]); // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]); &#125; &#125; return arr;&#125; 算法示意图 十.基数排序算法原理基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法步骤 取得数组中的最大数，并取得位数； arr为原始数组，从最低位开始取每个位组成radix数组； 对radix进行计数排序（利用计数排序适用于小范围数的特点）； 代码实现(js)123456789101112131415161718192021222324var counter = [];function radixSort(arr, maxDigit) &#123; var mod = 10; var dev = 1; for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) &#123; for(var j = 0; j &lt; arr.length; j++) &#123; var bucket = parseInt((arr[j] % mod) / dev); if(counter[bucket]==null) &#123; counter[bucket] = []; &#125; counter[bucket].push(arr[j]); &#125; var pos = 0; for(var j = 0; j &lt; counter.length; j++) &#123; var value = null; if(counter[j]!=null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos++] = value; &#125; &#125; &#125; &#125; return arr;&#125; 算法示意图 算法复杂度这只是部分的 关于此篇博客 希尔排序我感觉一般所以直接搬用了其他博主的代码与解析，其原理和实现我都自己做了。最后三个排序我感觉蠢蠢的但是肯定也有它们的应用场景，实现起来也特简单，所以我就直接搬用了其他博主的博客内容。整个博客其实就是自己学习所用，来试试自己学的怎样了，结果感觉还行。整个博客都是用自己的通俗的理解写出来的，主要是为了给自己复习，写的易懂一些，所以肯定很不严谨，欢迎各位的批评指正，我会及时修改。 引用博客 https://www.cnblogs.com/RainyBear/p/5258483.htmlhttps://www.cnblogs.com/onepixel/articles/7674659.html]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to my blog]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>centOS</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
</search>
